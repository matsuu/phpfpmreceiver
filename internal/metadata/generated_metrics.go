// Code generated by mdatagen. DO NOT EDIT.

package metadata

import (
	"time"

	"go.opentelemetry.io/collector/component"
	"go.opentelemetry.io/collector/filter"
	"go.opentelemetry.io/collector/pdata/pcommon"
	"go.opentelemetry.io/collector/pdata/pmetric"
	"go.opentelemetry.io/collector/receiver"
)

type metricPhpfpmAcceptedConnections struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills phpfpm.accepted_connections metric with initial data.
func (m *metricPhpfpmAcceptedConnections) init() {
	m.data.SetName("phpfpm.accepted_connections")
	m.data.SetDescription("The number of requests accepted by the pool")
	m.data.SetUnit("{connections}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricPhpfpmAcceptedConnections) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricPhpfpmAcceptedConnections) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricPhpfpmAcceptedConnections) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricPhpfpmAcceptedConnections(cfg MetricConfig) metricPhpfpmAcceptedConnections {
	m := metricPhpfpmAcceptedConnections{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricPhpfpmActiveProcesses struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills phpfpm.active_processes metric with initial data.
func (m *metricPhpfpmActiveProcesses) init() {
	m.data.SetName("phpfpm.active_processes")
	m.data.SetDescription("The number of active processes")
	m.data.SetUnit("{processes}")
	m.data.SetEmptyGauge()
}

func (m *metricPhpfpmActiveProcesses) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricPhpfpmActiveProcesses) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricPhpfpmActiveProcesses) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricPhpfpmActiveProcesses(cfg MetricConfig) metricPhpfpmActiveProcesses {
	m := metricPhpfpmActiveProcesses{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricPhpfpmIdleProcesses struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills phpfpm.idle_processes metric with initial data.
func (m *metricPhpfpmIdleProcesses) init() {
	m.data.SetName("phpfpm.idle_processes")
	m.data.SetDescription("The The number of idle processes")
	m.data.SetUnit("{processes}")
	m.data.SetEmptyGauge()
}

func (m *metricPhpfpmIdleProcesses) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricPhpfpmIdleProcesses) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricPhpfpmIdleProcesses) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricPhpfpmIdleProcesses(cfg MetricConfig) metricPhpfpmIdleProcesses {
	m := metricPhpfpmIdleProcesses{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricPhpfpmListenQueue struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills phpfpm.listen_queue metric with initial data.
func (m *metricPhpfpmListenQueue) init() {
	m.data.SetName("phpfpm.listen_queue")
	m.data.SetDescription("The number of requests in the queue of pending connections")
	m.data.SetUnit("{requests}")
	m.data.SetEmptyGauge()
}

func (m *metricPhpfpmListenQueue) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricPhpfpmListenQueue) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricPhpfpmListenQueue) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricPhpfpmListenQueue(cfg MetricConfig) metricPhpfpmListenQueue {
	m := metricPhpfpmListenQueue{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricPhpfpmListenQueueLength struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills phpfpm.listen_queue_length metric with initial data.
func (m *metricPhpfpmListenQueueLength) init() {
	m.data.SetName("phpfpm.listen_queue_length")
	m.data.SetDescription("The size of the socket queue of pending connections")
	m.data.SetUnit("{requests}")
	m.data.SetEmptyGauge()
}

func (m *metricPhpfpmListenQueueLength) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricPhpfpmListenQueueLength) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricPhpfpmListenQueueLength) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricPhpfpmListenQueueLength(cfg MetricConfig) metricPhpfpmListenQueueLength {
	m := metricPhpfpmListenQueueLength{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricPhpfpmMaxActiveProcesses struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills phpfpm.max_active_processes metric with initial data.
func (m *metricPhpfpmMaxActiveProcesses) init() {
	m.data.SetName("phpfpm.max_active_processes")
	m.data.SetDescription("The maximum number of requests in the queue of pending connections since FPM has started")
	m.data.SetUnit("{processes}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricPhpfpmMaxActiveProcesses) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricPhpfpmMaxActiveProcesses) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricPhpfpmMaxActiveProcesses) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricPhpfpmMaxActiveProcesses(cfg MetricConfig) metricPhpfpmMaxActiveProcesses {
	m := metricPhpfpmMaxActiveProcesses{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricPhpfpmMaxChildrenReached struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills phpfpm.max_children_reached metric with initial data.
func (m *metricPhpfpmMaxChildrenReached) init() {
	m.data.SetName("phpfpm.max_children_reached")
	m.data.SetDescription("The number of times, the process limit has been reached, when pm tries to start more children (works only for pm 'dynamic' and 'ondemand')")
	m.data.SetUnit("{processes}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricPhpfpmMaxChildrenReached) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricPhpfpmMaxChildrenReached) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricPhpfpmMaxChildrenReached) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricPhpfpmMaxChildrenReached(cfg MetricConfig) metricPhpfpmMaxChildrenReached {
	m := metricPhpfpmMaxChildrenReached{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricPhpfpmMaxListenQueue struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills phpfpm.max_listen_queue metric with initial data.
func (m *metricPhpfpmMaxListenQueue) init() {
	m.data.SetName("phpfpm.max_listen_queue")
	m.data.SetDescription("The maximum number of requests in the queue of pending connections since FPM has started")
	m.data.SetUnit("{requests}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricPhpfpmMaxListenQueue) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricPhpfpmMaxListenQueue) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricPhpfpmMaxListenQueue) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricPhpfpmMaxListenQueue(cfg MetricConfig) metricPhpfpmMaxListenQueue {
	m := metricPhpfpmMaxListenQueue{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricPhpfpmProcessLastRequestCPU struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills phpfpm.process.last_request_cpu metric with initial data.
func (m *metricPhpfpmProcessLastRequestCPU) init() {
	m.data.SetName("phpfpm.process.last_request_cpu")
	m.data.SetDescription("The %cpu the last request consumed")
	m.data.SetUnit("%")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricPhpfpmProcessLastRequestCPU) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, childAttributeValue int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutInt("child", childAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricPhpfpmProcessLastRequestCPU) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricPhpfpmProcessLastRequestCPU) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricPhpfpmProcessLastRequestCPU(cfg MetricConfig) metricPhpfpmProcessLastRequestCPU {
	m := metricPhpfpmProcessLastRequestCPU{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricPhpfpmProcessLastRequestMemory struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills phpfpm.process.last_request_memory metric with initial data.
func (m *metricPhpfpmProcessLastRequestMemory) init() {
	m.data.SetName("phpfpm.process.last_request_memory")
	m.data.SetDescription("The max amount of memory the last request consumed")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricPhpfpmProcessLastRequestMemory) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, childAttributeValue int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutInt("child", childAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricPhpfpmProcessLastRequestMemory) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricPhpfpmProcessLastRequestMemory) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricPhpfpmProcessLastRequestMemory(cfg MetricConfig) metricPhpfpmProcessLastRequestMemory {
	m := metricPhpfpmProcessLastRequestMemory{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricPhpfpmProcessRequestDuration struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills phpfpm.process.request_duration metric with initial data.
func (m *metricPhpfpmProcessRequestDuration) init() {
	m.data.SetName("phpfpm.process.request_duration")
	m.data.SetDescription("The duration in microseconds of the requests")
	m.data.SetUnit("us")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricPhpfpmProcessRequestDuration) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, childAttributeValue int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutInt("child", childAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricPhpfpmProcessRequestDuration) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricPhpfpmProcessRequestDuration) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricPhpfpmProcessRequestDuration(cfg MetricConfig) metricPhpfpmProcessRequestDuration {
	m := metricPhpfpmProcessRequestDuration{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricPhpfpmProcessRequests struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills phpfpm.process.requests metric with initial data.
func (m *metricPhpfpmProcessRequests) init() {
	m.data.SetName("phpfpm.process.requests")
	m.data.SetDescription("The number of requests the process has served")
	m.data.SetUnit("{requests}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricPhpfpmProcessRequests) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, childAttributeValue int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutInt("child", childAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricPhpfpmProcessRequests) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricPhpfpmProcessRequests) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricPhpfpmProcessRequests(cfg MetricConfig) metricPhpfpmProcessRequests {
	m := metricPhpfpmProcessRequests{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricPhpfpmProcessState struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills phpfpm.process.state metric with initial data.
func (m *metricPhpfpmProcessState) init() {
	m.data.SetName("phpfpm.process.state")
	m.data.SetDescription("The state of the process (Idle, Running, ...)")
	m.data.SetUnit("{processes}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricPhpfpmProcessState) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, childAttributeValue int64, stateAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutInt("child", childAttributeValue)
	dp.Attributes().PutStr("state", stateAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricPhpfpmProcessState) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricPhpfpmProcessState) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricPhpfpmProcessState(cfg MetricConfig) metricPhpfpmProcessState {
	m := metricPhpfpmProcessState{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricPhpfpmScrapeFailures struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills phpfpm.scrape_failures metric with initial data.
func (m *metricPhpfpmScrapeFailures) init() {
	m.data.SetName("phpfpm.scrape_failures")
	m.data.SetDescription("The number of failures scraping from PHP-FPM")
	m.data.SetUnit("{requests}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricPhpfpmScrapeFailures) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricPhpfpmScrapeFailures) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricPhpfpmScrapeFailures) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricPhpfpmScrapeFailures(cfg MetricConfig) metricPhpfpmScrapeFailures {
	m := metricPhpfpmScrapeFailures{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricPhpfpmSlowRequests struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills phpfpm.slow_requests metric with initial data.
func (m *metricPhpfpmSlowRequests) init() {
	m.data.SetName("phpfpm.slow_requests")
	m.data.SetDescription("The number of requests that exceeded your 'request_slowlog_timeout' value")
	m.data.SetUnit("{requests}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricPhpfpmSlowRequests) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricPhpfpmSlowRequests) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricPhpfpmSlowRequests) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricPhpfpmSlowRequests(cfg MetricConfig) metricPhpfpmSlowRequests {
	m := metricPhpfpmSlowRequests{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricPhpfpmStartSince struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills phpfpm.start_since metric with initial data.
func (m *metricPhpfpmStartSince) init() {
	m.data.SetName("phpfpm.start_since")
	m.data.SetDescription("The number of seconds since FPM has started")
	m.data.SetUnit("s")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricPhpfpmStartSince) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricPhpfpmStartSince) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricPhpfpmStartSince) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricPhpfpmStartSince(cfg MetricConfig) metricPhpfpmStartSince {
	m := metricPhpfpmStartSince{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricPhpfpmTotalProcesses struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills phpfpm.total_processes metric with initial data.
func (m *metricPhpfpmTotalProcesses) init() {
	m.data.SetName("phpfpm.total_processes")
	m.data.SetDescription("The number of idle + active processes")
	m.data.SetUnit("{processes}")
	m.data.SetEmptyGauge()
}

func (m *metricPhpfpmTotalProcesses) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricPhpfpmTotalProcesses) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricPhpfpmTotalProcesses) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricPhpfpmTotalProcesses(cfg MetricConfig) metricPhpfpmTotalProcesses {
	m := metricPhpfpmTotalProcesses{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

// MetricsBuilder provides an interface for scrapers to report metrics while taking care of all the transformations
// required to produce metric representation defined in metadata and user config.
type MetricsBuilder struct {
	config                               MetricsBuilderConfig // config of the metrics builder.
	startTime                            pcommon.Timestamp    // start time that will be applied to all recorded data points.
	metricsCapacity                      int                  // maximum observed number of metrics per resource.
	metricsBuffer                        pmetric.Metrics      // accumulates metrics data before emitting.
	buildInfo                            component.BuildInfo  // contains version information.
	resourceAttributeIncludeFilter       map[string]filter.Filter
	resourceAttributeExcludeFilter       map[string]filter.Filter
	metricPhpfpmAcceptedConnections      metricPhpfpmAcceptedConnections
	metricPhpfpmActiveProcesses          metricPhpfpmActiveProcesses
	metricPhpfpmIdleProcesses            metricPhpfpmIdleProcesses
	metricPhpfpmListenQueue              metricPhpfpmListenQueue
	metricPhpfpmListenQueueLength        metricPhpfpmListenQueueLength
	metricPhpfpmMaxActiveProcesses       metricPhpfpmMaxActiveProcesses
	metricPhpfpmMaxChildrenReached       metricPhpfpmMaxChildrenReached
	metricPhpfpmMaxListenQueue           metricPhpfpmMaxListenQueue
	metricPhpfpmProcessLastRequestCPU    metricPhpfpmProcessLastRequestCPU
	metricPhpfpmProcessLastRequestMemory metricPhpfpmProcessLastRequestMemory
	metricPhpfpmProcessRequestDuration   metricPhpfpmProcessRequestDuration
	metricPhpfpmProcessRequests          metricPhpfpmProcessRequests
	metricPhpfpmProcessState             metricPhpfpmProcessState
	metricPhpfpmScrapeFailures           metricPhpfpmScrapeFailures
	metricPhpfpmSlowRequests             metricPhpfpmSlowRequests
	metricPhpfpmStartSince               metricPhpfpmStartSince
	metricPhpfpmTotalProcesses           metricPhpfpmTotalProcesses
}

// MetricBuilderOption applies changes to default metrics builder.
type MetricBuilderOption interface {
	apply(*MetricsBuilder)
}

type metricBuilderOptionFunc func(mb *MetricsBuilder)

func (mbof metricBuilderOptionFunc) apply(mb *MetricsBuilder) {
	mbof(mb)
}

// WithStartTime sets startTime on the metrics builder.
func WithStartTime(startTime pcommon.Timestamp) MetricBuilderOption {
	return metricBuilderOptionFunc(func(mb *MetricsBuilder) {
		mb.startTime = startTime
	})
}
func NewMetricsBuilder(mbc MetricsBuilderConfig, settings receiver.Settings, options ...MetricBuilderOption) *MetricsBuilder {
	mb := &MetricsBuilder{
		config:                               mbc,
		startTime:                            pcommon.NewTimestampFromTime(time.Now()),
		metricsBuffer:                        pmetric.NewMetrics(),
		buildInfo:                            settings.BuildInfo,
		metricPhpfpmAcceptedConnections:      newMetricPhpfpmAcceptedConnections(mbc.Metrics.PhpfpmAcceptedConnections),
		metricPhpfpmActiveProcesses:          newMetricPhpfpmActiveProcesses(mbc.Metrics.PhpfpmActiveProcesses),
		metricPhpfpmIdleProcesses:            newMetricPhpfpmIdleProcesses(mbc.Metrics.PhpfpmIdleProcesses),
		metricPhpfpmListenQueue:              newMetricPhpfpmListenQueue(mbc.Metrics.PhpfpmListenQueue),
		metricPhpfpmListenQueueLength:        newMetricPhpfpmListenQueueLength(mbc.Metrics.PhpfpmListenQueueLength),
		metricPhpfpmMaxActiveProcesses:       newMetricPhpfpmMaxActiveProcesses(mbc.Metrics.PhpfpmMaxActiveProcesses),
		metricPhpfpmMaxChildrenReached:       newMetricPhpfpmMaxChildrenReached(mbc.Metrics.PhpfpmMaxChildrenReached),
		metricPhpfpmMaxListenQueue:           newMetricPhpfpmMaxListenQueue(mbc.Metrics.PhpfpmMaxListenQueue),
		metricPhpfpmProcessLastRequestCPU:    newMetricPhpfpmProcessLastRequestCPU(mbc.Metrics.PhpfpmProcessLastRequestCPU),
		metricPhpfpmProcessLastRequestMemory: newMetricPhpfpmProcessLastRequestMemory(mbc.Metrics.PhpfpmProcessLastRequestMemory),
		metricPhpfpmProcessRequestDuration:   newMetricPhpfpmProcessRequestDuration(mbc.Metrics.PhpfpmProcessRequestDuration),
		metricPhpfpmProcessRequests:          newMetricPhpfpmProcessRequests(mbc.Metrics.PhpfpmProcessRequests),
		metricPhpfpmProcessState:             newMetricPhpfpmProcessState(mbc.Metrics.PhpfpmProcessState),
		metricPhpfpmScrapeFailures:           newMetricPhpfpmScrapeFailures(mbc.Metrics.PhpfpmScrapeFailures),
		metricPhpfpmSlowRequests:             newMetricPhpfpmSlowRequests(mbc.Metrics.PhpfpmSlowRequests),
		metricPhpfpmStartSince:               newMetricPhpfpmStartSince(mbc.Metrics.PhpfpmStartSince),
		metricPhpfpmTotalProcesses:           newMetricPhpfpmTotalProcesses(mbc.Metrics.PhpfpmTotalProcesses),
		resourceAttributeIncludeFilter:       make(map[string]filter.Filter),
		resourceAttributeExcludeFilter:       make(map[string]filter.Filter),
	}
	if mbc.ResourceAttributes.PhpfpmPoolName.MetricsInclude != nil {
		mb.resourceAttributeIncludeFilter["phpfpm.pool_name"] = filter.CreateFilter(mbc.ResourceAttributes.PhpfpmPoolName.MetricsInclude)
	}
	if mbc.ResourceAttributes.PhpfpmPoolName.MetricsExclude != nil {
		mb.resourceAttributeExcludeFilter["phpfpm.pool_name"] = filter.CreateFilter(mbc.ResourceAttributes.PhpfpmPoolName.MetricsExclude)
	}
	if mbc.ResourceAttributes.PhpfpmScrapeURI.MetricsInclude != nil {
		mb.resourceAttributeIncludeFilter["phpfpm.scrape_uri"] = filter.CreateFilter(mbc.ResourceAttributes.PhpfpmScrapeURI.MetricsInclude)
	}
	if mbc.ResourceAttributes.PhpfpmScrapeURI.MetricsExclude != nil {
		mb.resourceAttributeExcludeFilter["phpfpm.scrape_uri"] = filter.CreateFilter(mbc.ResourceAttributes.PhpfpmScrapeURI.MetricsExclude)
	}

	for _, op := range options {
		op.apply(mb)
	}
	return mb
}

// NewResourceBuilder returns a new resource builder that should be used to build a resource associated with for the emitted metrics.
func (mb *MetricsBuilder) NewResourceBuilder() *ResourceBuilder {
	return NewResourceBuilder(mb.config.ResourceAttributes)
}

// updateCapacity updates max length of metrics and resource attributes that will be used for the slice capacity.
func (mb *MetricsBuilder) updateCapacity(rm pmetric.ResourceMetrics) {
	if mb.metricsCapacity < rm.ScopeMetrics().At(0).Metrics().Len() {
		mb.metricsCapacity = rm.ScopeMetrics().At(0).Metrics().Len()
	}
}

// ResourceMetricsOption applies changes to provided resource metrics.
type ResourceMetricsOption interface {
	apply(pmetric.ResourceMetrics)
}

type resourceMetricsOptionFunc func(pmetric.ResourceMetrics)

func (rmof resourceMetricsOptionFunc) apply(rm pmetric.ResourceMetrics) {
	rmof(rm)
}

// WithResource sets the provided resource on the emitted ResourceMetrics.
// It's recommended to use ResourceBuilder to create the resource.
func WithResource(res pcommon.Resource) ResourceMetricsOption {
	return resourceMetricsOptionFunc(func(rm pmetric.ResourceMetrics) {
		res.CopyTo(rm.Resource())
	})
}

// WithStartTimeOverride overrides start time for all the resource metrics data points.
// This option should be only used if different start time has to be set on metrics coming from different resources.
func WithStartTimeOverride(start pcommon.Timestamp) ResourceMetricsOption {
	return resourceMetricsOptionFunc(func(rm pmetric.ResourceMetrics) {
		var dps pmetric.NumberDataPointSlice
		metrics := rm.ScopeMetrics().At(0).Metrics()
		for i := 0; i < metrics.Len(); i++ {
			switch metrics.At(i).Type() {
			case pmetric.MetricTypeGauge:
				dps = metrics.At(i).Gauge().DataPoints()
			case pmetric.MetricTypeSum:
				dps = metrics.At(i).Sum().DataPoints()
			}
			for j := 0; j < dps.Len(); j++ {
				dps.At(j).SetStartTimestamp(start)
			}
		}
	})
}

// EmitForResource saves all the generated metrics under a new resource and updates the internal state to be ready for
// recording another set of data points as part of another resource. This function can be helpful when one scraper
// needs to emit metrics from several resources. Otherwise calling this function is not required,
// just `Emit` function can be called instead.
// Resource attributes should be provided as ResourceMetricsOption arguments.
func (mb *MetricsBuilder) EmitForResource(options ...ResourceMetricsOption) {
	rm := pmetric.NewResourceMetrics()
	ils := rm.ScopeMetrics().AppendEmpty()
	ils.Scope().SetName("github.com/matsuu/phpfpmreceiver")
	ils.Scope().SetVersion(mb.buildInfo.Version)
	ils.Metrics().EnsureCapacity(mb.metricsCapacity)
	mb.metricPhpfpmAcceptedConnections.emit(ils.Metrics())
	mb.metricPhpfpmActiveProcesses.emit(ils.Metrics())
	mb.metricPhpfpmIdleProcesses.emit(ils.Metrics())
	mb.metricPhpfpmListenQueue.emit(ils.Metrics())
	mb.metricPhpfpmListenQueueLength.emit(ils.Metrics())
	mb.metricPhpfpmMaxActiveProcesses.emit(ils.Metrics())
	mb.metricPhpfpmMaxChildrenReached.emit(ils.Metrics())
	mb.metricPhpfpmMaxListenQueue.emit(ils.Metrics())
	mb.metricPhpfpmProcessLastRequestCPU.emit(ils.Metrics())
	mb.metricPhpfpmProcessLastRequestMemory.emit(ils.Metrics())
	mb.metricPhpfpmProcessRequestDuration.emit(ils.Metrics())
	mb.metricPhpfpmProcessRequests.emit(ils.Metrics())
	mb.metricPhpfpmProcessState.emit(ils.Metrics())
	mb.metricPhpfpmScrapeFailures.emit(ils.Metrics())
	mb.metricPhpfpmSlowRequests.emit(ils.Metrics())
	mb.metricPhpfpmStartSince.emit(ils.Metrics())
	mb.metricPhpfpmTotalProcesses.emit(ils.Metrics())

	for _, op := range options {
		op.apply(rm)
	}
	for attr, filter := range mb.resourceAttributeIncludeFilter {
		if val, ok := rm.Resource().Attributes().Get(attr); ok && !filter.Matches(val.AsString()) {
			return
		}
	}
	for attr, filter := range mb.resourceAttributeExcludeFilter {
		if val, ok := rm.Resource().Attributes().Get(attr); ok && filter.Matches(val.AsString()) {
			return
		}
	}

	if ils.Metrics().Len() > 0 {
		mb.updateCapacity(rm)
		rm.MoveTo(mb.metricsBuffer.ResourceMetrics().AppendEmpty())
	}
}

// Emit returns all the metrics accumulated by the metrics builder and updates the internal state to be ready for
// recording another set of metrics. This function will be responsible for applying all the transformations required to
// produce metric representation defined in metadata and user config, e.g. delta or cumulative.
func (mb *MetricsBuilder) Emit(options ...ResourceMetricsOption) pmetric.Metrics {
	mb.EmitForResource(options...)
	metrics := mb.metricsBuffer
	mb.metricsBuffer = pmetric.NewMetrics()
	return metrics
}

// RecordPhpfpmAcceptedConnectionsDataPoint adds a data point to phpfpm.accepted_connections metric.
func (mb *MetricsBuilder) RecordPhpfpmAcceptedConnectionsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricPhpfpmAcceptedConnections.recordDataPoint(mb.startTime, ts, val)
}

// RecordPhpfpmActiveProcessesDataPoint adds a data point to phpfpm.active_processes metric.
func (mb *MetricsBuilder) RecordPhpfpmActiveProcessesDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricPhpfpmActiveProcesses.recordDataPoint(mb.startTime, ts, val)
}

// RecordPhpfpmIdleProcessesDataPoint adds a data point to phpfpm.idle_processes metric.
func (mb *MetricsBuilder) RecordPhpfpmIdleProcessesDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricPhpfpmIdleProcesses.recordDataPoint(mb.startTime, ts, val)
}

// RecordPhpfpmListenQueueDataPoint adds a data point to phpfpm.listen_queue metric.
func (mb *MetricsBuilder) RecordPhpfpmListenQueueDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricPhpfpmListenQueue.recordDataPoint(mb.startTime, ts, val)
}

// RecordPhpfpmListenQueueLengthDataPoint adds a data point to phpfpm.listen_queue_length metric.
func (mb *MetricsBuilder) RecordPhpfpmListenQueueLengthDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricPhpfpmListenQueueLength.recordDataPoint(mb.startTime, ts, val)
}

// RecordPhpfpmMaxActiveProcessesDataPoint adds a data point to phpfpm.max_active_processes metric.
func (mb *MetricsBuilder) RecordPhpfpmMaxActiveProcessesDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricPhpfpmMaxActiveProcesses.recordDataPoint(mb.startTime, ts, val)
}

// RecordPhpfpmMaxChildrenReachedDataPoint adds a data point to phpfpm.max_children_reached metric.
func (mb *MetricsBuilder) RecordPhpfpmMaxChildrenReachedDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricPhpfpmMaxChildrenReached.recordDataPoint(mb.startTime, ts, val)
}

// RecordPhpfpmMaxListenQueueDataPoint adds a data point to phpfpm.max_listen_queue metric.
func (mb *MetricsBuilder) RecordPhpfpmMaxListenQueueDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricPhpfpmMaxListenQueue.recordDataPoint(mb.startTime, ts, val)
}

// RecordPhpfpmProcessLastRequestCPUDataPoint adds a data point to phpfpm.process.last_request_cpu metric.
func (mb *MetricsBuilder) RecordPhpfpmProcessLastRequestCPUDataPoint(ts pcommon.Timestamp, val float64, childAttributeValue int64) {
	mb.metricPhpfpmProcessLastRequestCPU.recordDataPoint(mb.startTime, ts, val, childAttributeValue)
}

// RecordPhpfpmProcessLastRequestMemoryDataPoint adds a data point to phpfpm.process.last_request_memory metric.
func (mb *MetricsBuilder) RecordPhpfpmProcessLastRequestMemoryDataPoint(ts pcommon.Timestamp, val int64, childAttributeValue int64) {
	mb.metricPhpfpmProcessLastRequestMemory.recordDataPoint(mb.startTime, ts, val, childAttributeValue)
}

// RecordPhpfpmProcessRequestDurationDataPoint adds a data point to phpfpm.process.request_duration metric.
func (mb *MetricsBuilder) RecordPhpfpmProcessRequestDurationDataPoint(ts pcommon.Timestamp, val int64, childAttributeValue int64) {
	mb.metricPhpfpmProcessRequestDuration.recordDataPoint(mb.startTime, ts, val, childAttributeValue)
}

// RecordPhpfpmProcessRequestsDataPoint adds a data point to phpfpm.process.requests metric.
func (mb *MetricsBuilder) RecordPhpfpmProcessRequestsDataPoint(ts pcommon.Timestamp, val int64, childAttributeValue int64) {
	mb.metricPhpfpmProcessRequests.recordDataPoint(mb.startTime, ts, val, childAttributeValue)
}

// RecordPhpfpmProcessStateDataPoint adds a data point to phpfpm.process.state metric.
func (mb *MetricsBuilder) RecordPhpfpmProcessStateDataPoint(ts pcommon.Timestamp, val int64, childAttributeValue int64, stateAttributeValue string) {
	mb.metricPhpfpmProcessState.recordDataPoint(mb.startTime, ts, val, childAttributeValue, stateAttributeValue)
}

// RecordPhpfpmScrapeFailuresDataPoint adds a data point to phpfpm.scrape_failures metric.
func (mb *MetricsBuilder) RecordPhpfpmScrapeFailuresDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricPhpfpmScrapeFailures.recordDataPoint(mb.startTime, ts, val)
}

// RecordPhpfpmSlowRequestsDataPoint adds a data point to phpfpm.slow_requests metric.
func (mb *MetricsBuilder) RecordPhpfpmSlowRequestsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricPhpfpmSlowRequests.recordDataPoint(mb.startTime, ts, val)
}

// RecordPhpfpmStartSinceDataPoint adds a data point to phpfpm.start_since metric.
func (mb *MetricsBuilder) RecordPhpfpmStartSinceDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricPhpfpmStartSince.recordDataPoint(mb.startTime, ts, val)
}

// RecordPhpfpmTotalProcessesDataPoint adds a data point to phpfpm.total_processes metric.
func (mb *MetricsBuilder) RecordPhpfpmTotalProcessesDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricPhpfpmTotalProcesses.recordDataPoint(mb.startTime, ts, val)
}

// Reset resets metrics builder to its initial state. It should be used when external metrics source is restarted,
// and metrics builder should update its startTime and reset it's internal state accordingly.
func (mb *MetricsBuilder) Reset(options ...MetricBuilderOption) {
	mb.startTime = pcommon.NewTimestampFromTime(time.Now())
	for _, op := range options {
		op.apply(mb)
	}
}
